#!/bin/bash

echo "üîß SOLAR v2.0 - –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≥–æ—Ç–æ–≤—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ —Å OpenAI API"
echo "========================================================="

cd b/src/

# –°–æ–∑–¥–∞–µ–º –≥–ª–∞–≤–Ω—ã–π —Å–µ—Ä–≤–∏—Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏
echo "üåç –°–æ–∑–¥–∞–Ω–∏–µ UnifiedTranslationService..."
cat > services/unifiedTranslationService.js << 'EOF'
const OpenAI = require('openai');
const { transcribeAudio } = require('./whisperService');
const { speakText } = require('./textToSpeechService');
const fs = require('fs');
const path = require('path');

class UnifiedTranslationService {
  constructor() {
    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    
    // –í–∞—à–∏ –≥–æ—Ç–æ–≤—ã–µ —è–∑—ã–∫–æ–≤—ã–µ –ø–∞—Ä—ã
    this.supportedLanguages = {
      'EN': { name: 'English', flag: 'üá∫üá∏', code: 'en' },
      'RU': { name: '–†—É—Å—Å–∫–∏–π', flag: 'üá∑üá∫', code: 'ru' },
      'DE': { name: 'Deutsch', flag: 'üá©üá™', code: 'de' },
      'ES': { name: 'Espa√±ol', flag: 'üá™üá∏', code: 'es' },
      'CS': { name: 'ƒåe≈°tina', flag: 'üá®üáø', code: 'cs' },
      'PL': { name: 'Polski', flag: 'üáµüá±', code: 'pl' },
      'LT': { name: 'Lietuvi≈≥', flag: 'üá±üáπ', code: 'lt' },
      'LV': { name: 'Latvie≈°u', flag: 'üá±üáª', code: 'lv' },
      'NO': { name: 'Norsk', flag: 'üá≥üá¥', code: 'no' }
    };

    // –ì–æ—Ç–æ–≤—ã–µ —è–∑—ã–∫–æ–≤—ã–µ –ø–∞—Ä—ã –∏–∑ –≤–∞—à–µ–π —ç–∫–æ—Å–∏—Å—Ç–µ–º—ã
    this.availablePairs = [
      'EN-RU', 'RU-EN', 'DE-RU', 'RU-DE',
      'CS-RU', 'ES-RU', 'LT-RU', 'LV-RU', 
      'NO-RU', 'PL-RU'
    ];
    
    console.log('üåç Unified Translation Service –≥–æ—Ç–æ–≤ —Å', Object.keys(this.supportedLanguages).length, '—è–∑—ã–∫–∞–º–∏');
  }

  // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —è–∑—ã–∫–∏ –¥–ª—è Frontend
  getSupportedLanguages() {
    return Object.entries(this.supportedLanguages).map(([code, config]) => ({
      code,
      name: config.name,
      flag: config.flag,
      nativeName: config.name
    }));
  }

  // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–¥–µ—Ä–∂–∫—É —è–∑—ã–∫–æ–≤–æ–π –ø–∞—Ä—ã
  isPairSupported(fromLanguage, toLanguage) {
    const directPair = `${fromLanguage}-${toLanguage}`;
    const reversePair = `${toLanguage}-${fromLanguage}`;
    
    return this.availablePairs.includes(directPair) || 
           this.availablePairs.includes(reversePair) ||
           this.supportedLanguages[fromLanguage] && this.supportedLanguages[toLanguage];
  }

  // –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –ø–µ—Ä–µ–≤–æ–¥–∞ —Ç–µ–∫—Å—Ç–∞ —Å OpenAI
  async translateText(text, fromLanguage, toLanguage) {
    const startTime = Date.now();
    
    try {
      // –í–∞–ª–∏–¥–∞—Ü–∏—è
      if (!this.supportedLanguages[fromLanguage] || !this.supportedLanguages[toLanguage]) {
        throw new Error(`Unsupported language pair: ${fromLanguage} ‚Üí ${toLanguage}`);
      }

      if (fromLanguage === toLanguage) {
        return {
          originalText: text,
          translatedText: text,
          fromLanguage,
          toLanguage,
          processingTime: Date.now() - startTime,
          confidence: 1.0,
          provider: 'same-language'
        };
      }

      // –ò—Å–ø–æ–ª—å–∑—É–µ–º OpenAI –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ (–≤–∞—à –≥–æ—Ç–æ–≤—ã–π API –∫–ª—é—á)
      const fromLang = this.supportedLanguages[fromLanguage].name;
      const toLang = this.supportedLanguages[toLanguage].name;
      
      const systemPrompt = `You are a professional translator. Translate the following text from ${fromLang} to ${toLang}. 
      
RULES:
- Provide ONLY the translation, no explanations
- Maintain the original tone and style
- Keep formatting if any
- For voice messages, translate naturally and conversationally`;

      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: text }
        ],
        max_tokens: Math.min(4000, text.length * 3),
        temperature: 0.3
      });

      const translatedText = response.choices[0]?.message?.content?.trim();
      
      if (!translatedText) {
        throw new Error('Translation failed');
      }

      return {
        originalText: text,
        translatedText,
        fromLanguage,
        toLanguage,
        processingTime: Date.now() - startTime,
        confidence: 0.95,
        provider: 'openai-gpt4o-mini',
        usage: response.usage
      };

    } catch (error) {
      console.error('Translation error:', error);
      throw new Error(`Translation failed: ${error.message}`);
    }
  }

  // Voice-to-Voice –ø–µ—Ä–µ–≤–æ–¥ –∏—Å–ø–æ–ª—å–∑—É—è –≤–∞—à–∏ –≥–æ—Ç–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã
  async translateVoice(audioFilePath, fromLanguage, toLanguage) {
    const startTime = Date.now();
    
    try {
      console.log('üé§ Starting voice translation:', { fromLanguage, toLanguage });
      
      // 1. –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏ (–≤–∞—à –≥–æ—Ç–æ–≤—ã–π whisperService)
      const transcript = await transcribeAudio(audioFilePath, this.supportedLanguages[fromLanguage].code);
      console.log('üìù Transcript:', transcript);
      
      // 2. –ü–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞ (OpenAI)
      const translation = await this.translateText(transcript, fromLanguage, toLanguage);
      console.log('üåç Translation:', translation.translatedText);
      
      // 3. –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ—á–∏ (–≤–∞—à –≥–æ—Ç–æ–≤—ã–π textToSpeechService)
      const audioPath = await speakText(translation.translatedText, this.supportedLanguages[toLanguage].code);
      console.log('üîä Audio generated:', audioPath);
      
      return {
        originalText: transcript,
        translatedText: translation.translatedText,
        originalAudio: audioFilePath,
        translatedAudio: audioPath,
        fromLanguage,
        toLanguage,
        processingTime: Date.now() - startTime,
        confidence: translation.confidence,
        provider: 'solar-voice-pipeline'
      };

    } catch (error) {
      console.error('Voice translation error:', error);
      throw new Error(`Voice translation failed: ${error.message}`);
    }
  }

  // –ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞
  async detectLanguage(text) {
    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: `Detect the language of the given text. Respond with ONLY the ISO language code from this list: EN, RU, DE, ES, CS, PL, LT, LV, NO. If uncertain, respond with "EN".`
          },
          { role: 'user', content: text.substring(0, 500) }
        ],
        max_tokens: 10,
        temperature: 0.1
      });

      const detectedCode = response.choices[0]?.message?.content?.trim();
      
      if (this.supportedLanguages[detectedCode]) {
        return {
          language: detectedCode,
          confidence: 0.9,
          provider: 'openai-detection'
        };
      }

      return {
        language: 'EN',
        confidence: 0.5,
        provider: 'fallback'
      };

    } catch (error) {
      console.error('Language detection error:', error);
      return {
        language: 'EN',
        confidence: 0.3,
        provider: 'error-fallback'
      };
    }
  }

  // –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  getStats() {
    return {
      supportedLanguages: Object.keys(this.supportedLanguages).length,
      availablePairs: this.availablePairs.length,
      features: [
        'text-translation',
        'voice-translation', 
        'language-detection',
        'real-time-processing'
      ],
      provider: 'SOLAR v2.0 + OpenAI',
      readyServices: [
        'whisperService',
        'textToSpeechService',
        'smartVoicePipeline',
        '12 Telegram Bots'
      ]
    };
  }
}

module.exports = { UnifiedTranslationService };
EOF

# –û–±–Ω–æ–≤–ª—è–µ–º routes/translate.js –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –Ω–æ–≤–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
echo "üõ£Ô∏è –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ Translation Routes..."
cat > routes/translate.js << 'EOF'
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { UnifiedTranslationService } = require('../services/unifiedTranslationService');

const router = express.Router();

// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ multer –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤
const upload = multer({
  dest: path.join(__dirname, '../../uploads/'),
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = ['audio/mpeg', 'audio/wav', 'audio/ogg', 'audio/webm'];
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type. Only audio files are allowed.'));
    }
  }
});

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å –ø–µ—Ä–µ–≤–æ–¥–∞
const translationService = new UnifiedTranslationService();

// GET /api/v2/translate/languages - –ü–æ–ª—É—á–∏—Ç—å –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —è–∑—ã–∫–∏
router.get('/languages', (req, res) => {
  try {
    const languages = translationService.getSupportedLanguages();
    res.json({
      success: true,
      data: {
        languages,
        stats: translationService.getStats()
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to get supported languages'
    });
  }
});

// POST /api/v2/translate/text - –ü–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞
router.post('/text', async (req, res) => {
  try {
    const { text, fromLanguage, toLanguage, autoDetect = false } = req.body;
    
    if (!text) {
      return res.status(400).json({
        success: false,
        error: 'Text is required'
      });
    }

    let sourceLang = fromLanguage;
    
    // –ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    if (autoDetect || !fromLanguage) {
      const detection = await translationService.detectLanguage(text);
      sourceLang = detection.language;
    }

    if (!toLanguage) {
      return res.status(400).json({
        success: false,
        error: 'Target language is required'
      });
    }

    // –í—ã–ø–æ–ª–Ω—è–µ–º –ø–µ—Ä–µ–≤–æ–¥
    const result = await translationService.translateText(text, sourceLang, toLanguage);
    
    res.json({
      success: true,
      data: {
        ...result,
        sessionId: `text-${Date.now()}`,
        autoDetected: autoDetect ? { language: sourceLang } : null
      }
    });

  } catch (error) {
    console.error('Text translation error:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'Text translation failed'
    });
  }
});

// POST /api/v2/translate/voice - –ü–µ—Ä–µ–≤–æ–¥ –≥–æ–ª–æ—Å–∞
router.post('/voice', upload.single('audio'), async (req, res) => {
  let uploadedFile = null;
  
  try {
    const { fromLanguage, toLanguage } = req.body;
    
    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'Audio file is required'
      });
    }

    if (!fromLanguage || !toLanguage) {
      return res.status(400).json({
        success: false,
        error: 'Both source and target languages are required'
      });
    }

    uploadedFile = req.file.path;
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º voice-to-voice –ø–µ—Ä–µ–≤–æ–¥
    const result = await translationService.translateVoice(uploadedFile, fromLanguage, toLanguage);
    
    // –ß–∏—Ç–∞–µ–º —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞—É–¥–∏–æ—Ñ–∞–π–ª
    let audioBase64 = null;
    if (result.translatedAudio && fs.existsSync(result.translatedAudio)) {
      const audioBuffer = fs.readFileSync(result.translatedAudio);
      audioBase64 = audioBuffer.toString('base64');
    }
    
    res.json({
      success: true,
      data: {
        originalText: result.originalText,
        translatedText: result.translatedText,
        translatedAudio: audioBase64,
        fromLanguage: result.fromLanguage,
        toLanguage: result.toLanguage,
        processingTime: result.processingTime,
        confidence: result.confidence,
        sessionId: `voice-${Date.now()}`
      }
    });

  } catch (error) {
    console.error('Voice translation error:', error);
    res.status(500).json({
      success: false,
      error: error.message || 'Voice translation failed'
    });
  } finally {
    // Cleanup uploaded file
    if (uploadedFile && fs.existsSync(uploadedFile)) {
      fs.unlink(uploadedFile, () => {});
    }
  }
});

// POST /api/v2/translate/detect - –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞
router.post('/detect', async (req, res) => {
  try {
    const { text } = req.body;
    
    if (!text) {
      return res.status(400).json({
        success: false,
        error: 'Text is required'
      });
    }

    const result = await translationService.detectLanguage(text);
    
    res.json({
      success: true,
      data: result
    });

  } catch (error) {
    console.error('Language detection error:', error);
    res.status(500).json({
      success: false,
      error: 'Language detection failed'
    });
  }
});

// GET /api/v2/translate/stats - –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–µ—Ä–≤–∏—Å–∞
router.get('/stats', (req, res) => {
  try {
    const stats = translationService.getStats();
    res.json({
      success: true,
      data: stats
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to get translation stats'
    });
  }
});

module.exports = router;
EOF

# –°–æ–∑–¥–∞–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–π translationService.js –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
echo "üîÑ –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–≤–º–µ—Å—Ç–∏–º–æ–≥–æ translationService..."
cat > services/translationService.js << 'EOF'
const { UnifiedTranslationService } = require('./unifiedTranslationService');

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –µ–¥–∏–Ω—ã–π —Å–µ—Ä–≤–∏—Å
const unifiedService = new UnifiedTranslationService();

// –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –±–æ—Ç–∞–º–∏
async function translateText(text, targetLang, sourceLang) {
  // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∫–æ–¥—ã —è–∑—ã–∫–æ–≤ –≤ –Ω–∞—à —Ñ–æ—Ä–º–∞—Ç
  const langMap = {
    'en': 'EN', 'ru': 'RU', 'de': 'DE', 'es': 'ES',
    'cs': 'CS', 'pl': 'PL', 'lt': 'LT', 'lv': 'LV', 'no': 'NO'
  };
  
  const fromLang = langMap[sourceLang] || sourceLang.toUpperCase();
  const toLang = langMap[targetLang] || targetLang.toUpperCase();
  
  try {
    const result = await unifiedService.translateText(text, fromLang, toLang);
    return result.translatedText;
  } catch (error) {
    console.error('Translation error:', error);
    throw error;
  }
}

module.exports = {
  translateText,
  UnifiedTranslationService: unifiedService
};
EOF

echo ""
echo "‚úÖ –ì–û–¢–û–í–û! –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞!"
echo ""
echo "üéØ –ß—Ç–æ —Å–æ–∑–¥–∞–Ω–æ:"
echo "- ‚úÖ UnifiedTranslationService (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç –≤–∞—à–∏ –≥–æ—Ç–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã)"
echo "- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å OpenAI API"
echo "- ‚úÖ –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ API routes –¥–ª—è Frontend"
echo "- ‚úÖ Voice-to-Voice pipeline"
echo "- ‚úÖ –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –±–æ—Ç–∞–º–∏"
echo ""
echo "üåç –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:"
echo "- üìù –¢–µ–∫—Å—Ç–æ–≤—ã–π –ø–µ—Ä–µ–≤–æ–¥ (9 —è–∑—ã–∫–æ–≤)"
echo "- üé§ –ì–æ–ª–æ—Å–æ–≤–æ–π –ø–µ—Ä–µ–≤–æ–¥ (Voice-to-Voice)"
echo "- üîç –ê–≤—Ç–æ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —è–∑—ã–∫–∞"
echo "- üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥"
echo ""
echo "üöÄ API Endpoints –≥–æ—Ç–æ–≤—ã:"
echo "- GET  /api/v2/translate/languages"
echo "- POST /api/v2/translate/text"
echo "- POST /api/v2/translate/voice"
echo "- POST /api/v2/translate/detect"
echo "- GET  /api/v2/translate/stats"
echo ""
echo "üî• Backend –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ —Å Frontend! –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä: npm run dev"
